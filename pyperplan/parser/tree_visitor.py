#
# This file is part of pyperplan.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#

"""
Classes and functions that traverse the HDDL abstract syntax tree (AST)
generated by pddl_parser.py, thereby creating the HDDL data structure.
"""

from . import hddl
from ..utils import LogicalOperator

class SemanticError(Exception):
    """Exception indicating an error during traversal of AST."""

    def __init__(self, value):
        """Constructor of SemanticError.

        Keyword arguments:
        value -- the error message
        """
        self.value = value

    def __str__(self):
        return repr(self.value)


class Visitable:
    """
    The Visitable class is part of the Visitor Pattern. Every AST node created
    by the Parser derives from this class.

    The accept-method calls the appropriate method of the visitor.
    """

    def __init__(self, vname=None):
        """Constructor of the Visitable.

        Keyword arguments:
        vname -- the name of the of the callback that will be called on the
                 visitor instance
        """
        self._visitorName = vname

    def accept(self, visitor):
        if self._visitorName == None:
            raise ValueError("Error: visit method of uninitialized visitor " "called!")
        # get the appropriate method of the visitor instance
        m = getattr(visitor, self._visitorName)
        # ensure that the method is callable
        if not hasattr(m, "__call__"):
            raise ValueError(
                "Error: cannot call undefined method: %s on "
                "visitor" % self._visitorName
            )
        # and finally call the callback
        m(self)


class HDDLVisitor:
    """
    The standard tree traversal HDDL Visitor from which other Visitors derive.

    In each node, the Visitor just applies itself to all its children.
    """

    def visit_domain_def(self, node):
        node.requirements.accept(self)
        
        if node.types != None:
            for t in node.types:
                t.accept(self)
        if node.constants != None:
            for c in node.constants:
                c.accept(self)
        node.predicates.accept(self)
        if node.actions != None:
            for a in node.actions:
                a.accept(self)
        
        if node.tasks != None:  
            for t in node.tasks:
                t.accept(self)
        
        if node.methods != None:
            for m in node.methods:
                m.accept(self)

    def visit_problem_def(self, node):
        for o in node.objects:
            o.accept(self)
        node.init.accept(self)
        node.htn.accept(self)
        if node.goal != None:
            node.goal.accept(self)

    def visit_predicates_stmt(self, node):
        for p in node.predicates:
            p.accept(self)
    
    def visit_task_stmt(self, node):
        for p in node.parameters:
            p.accept(self)

    def visit_action_stmt(self, node):
        for p in node.parameters:
            p.accept(self)
        node.precond.accept(self)
        node.effect.accept(self)

    def visit_method_stmt(self, node):
        for p in node.parameters:
            p.accept(self)
        node.precond.accept(self)
        node.decomposed_task.accept(self)
        node.ordered_subtasks.accept(self)

    def visit_htn_stmt(self, node):
        node.formula.accept(self)

    def visit_ordered_subtasks(self, node):
        node.formula.accept(self)

    def visit_decomposed_task_stmt(self, node):
        return 

    def visit_formula(self, node):
        for c in node.children:
            c.accept(self)

    def visit_type(self, node):
        return  # nothing to do right now

    def visit_effect_stmt(self, node):
        node.formula.accept(self)

    def visit_precondition_stmt(self, node):
        node.formula.accept(self)

    def visit_requirements_stmt(self, node):
        for k in node.keywords:
            k.accept(self)

    def visit_predicate(self, node):
        for p in node.parameters:
            p.accept(self)

    def visit_variable(self, node):
        pass

    def visit_init_stmt(self, node):
        for p in node.predicates:
            p.accept(self)

    def visit_goal_stmt(self, node):
        node.formula.accept(self)

    def visit_predicate_instance(self, node):
        return  # nothing to do right now

    def visit_object(self, node):
        return  # nothing to do right now

    def visit_keyword(self, node):
        return  # nothing to do right now

    



class TraverseHDDLDomain(HDDLVisitor):
    """The HDDL-domain Visitor.

    Expands the functionality of the HDDLVisitor to traversal of ASTs that
    represent a HDDL-domain file. It results in the HDDL data structure
    (pddl.py) representation of the domain file.
    """
    def get_in(self, node):
        """
        Helper method to access a global hash in which information for each
        node in the AST can be stored.
        """
        return self._nodeHash[node]

    def set_in(self, node, val):
        """
        Helper method to write a global hash in which information for each node
        in the AST can be stored.
        """
        self._nodeHash[node] = val

    def __init__(self):
        self._types = dict()
        self._predicates = dict()
        self._nodeHash = dict()
        self._requirements = set()
        self._actions = dict()
        self.domain = None
        self._objectType = hddl.Type("object", None)
        self._constants = dict()

        self._tasks = dict()
        self._methods = dict()

    def visit_domain_def(self, node):
        """Visits a HDDL domain definition."""
        explicitObjectDef = False
        
        # Requirements statement is optional.
        if node.requirements:
            node.requirements.accept(self)

        # Visit all type definitions.
        if node.types != None:
            for t in node.types:
                if t.name == "object":
                    explicitObjectDef = True
                t.accept(self)
                type = self.get_in(t)
                self._types[type.name] = type
                
        # Add the default object type to the type definitions,
        # if it was not explicitly created.
        if not explicitObjectDef:
            self._types["object"] = self._objectType

        '''
        #NOTE: here we need to allow new type instances in case the parent wasn't declared (apparently this is allowed)
        example: 
        Barman domain
        (:types
            anything
            container dispenser level beverage hand - anything
            shot shaker - container
            ingredient cocktail - beverage
        )
        should be equivalent to 
        (:types
            container dispenser level beverage hand - anything
            shot shaker - container
            ingredient cocktail - beverage
        )
        ''' 
        # Link all types to their parent types directly.
        for t in self._types.values():
            # Object type has no parent.
            if t.name == "object":
                continue
            if not t.parent in self._types:
                #t.parent.accept(self)
                #undeclared_type = self.get_in(t.parent)
                #self._types[undeclared_type.name] = undeclared_type
                raise SemanticError(f"[TYPE DECLARATION ERROR] parent type \'{t.parent}\' used in \'{t.name}\' not explicitly declared.") 
            
            t.parent = self._types[t.parent]

        # Visit all constants.
        if node.constants != None:
            for c in node.constants:
                c.accept(self)

        if node.tasks is not None:
            for t in node.tasks:
                t.accept(self)
                task = self.get_in(t)
                if task.name in self._tasks:
                    raise SemanticError(
                        "Error: task with name "
                        + task.name
                        + " has already been defined"
                    )
                self._tasks[task.name] = task
        
        # Visit all predicates.
        node.predicates.accept(self)
        
        # Visit all actions.
        if node.actions != None:
            for a in node.actions:
                a.accept(self)
                action = self.get_in(a)
                if action.name in self._actions:
                    raise SemanticError(
                        "Error: action with name "
                        + action.name
                        + " has already been defined"
                    )
                self._actions[action.name] = action

        # Visit all methods.
        if node.methods is not None:
            for m in node.methods:
                m.accept(self)
                method = self.get_in(m)
                if method.name in self._methods:
                    raise SemanticError(
                        "Error: method with name "
                        + task.method
                        + " has already been defined"
                    )
                self._methods[method.name] = method

        # Finally generate HDDL domain data structure.
        self.domain = hddl.Domain(
            node.name, self._types, self._predicates, self._tasks, self._actions, self._methods, self._constants
        )

    def visit_object(self, node):
        """Visits a HDDL object definition."""
        type_name = node.typeName
        if type_name == None:
            type_name = "object"
        if not type_name in self._types:
            raise SemanticError(
                "Error: unknown type \'" + type_name + "\' used in object definition!"
            )
        if node.name in self._constants:
            raise SemanticError(
                "Error: multiple defines of object with " "name " + node.name
            )
        # Add constant with its corresponding type to the constants dict.
        self._constants[node.name] = self._types[type_name]

    def visit_type(self, node):
        """Visits a HDDL type definition."""
        # Store matching parent type in node
        # (if none is given, it's always object)
        if node.parent == None:
            self.set_in(node, hddl.Type(node.name, "object"))
        else:
            self.set_in(node, hddl.Type(node.name, node.parent))

    def visit_requirements_stmt(self, node):
        """Visits a HDDL requirement statement."""
        # Visit all requirement keywords...
        for k in node.keywords:
            k.accept(self)
            requirementName = self.get_in(k)
            # ... and add them to the requirement list.
            self._requirements.add(requirementName)

    def visit_keyword(self, node):
        """Visits a HDDL keyword."""
        # Nothing to do but to store its name in the node.
        self.set_in(node, node.name)

    def visit_predicates_stmt(self, node):
        """Visits a HDDL predicate statement."""
        # Visit all predicates in the predicate statement.
        for p in node.predicates:
            p.accept(self)
            predicate = self.get_in(p)
            # Check for duplicate predicate definitions.
            if predicate.name in self._predicates:
                raise SemanticError(
                    "Error predicate with name "
                    + predicate.name
                    + " has already been defined"
                )
            # Add to predicate list.
            self._predicates[predicate.name] = predicate

    def visit_predicate(self, node):
        """Visits a HDDL predicate."""
        signature = list()
        # Visit all predicate parameters.
        for v in node.parameters:
            
            v.accept(self)
            signatureTuple = self.get_in(v)
            # Append each parameter to the predicate signature.
            signature.append(signatureTuple)
        # Create new HDDL predicate and store it in node.
        self.set_in(node, hddl.Predicate(node.name, signature))

    def visit_variable(self, node):
        """Visits a HDDL variable."""
        # If there is no type given, its always of type 'object'.
        if not node.typed:
            self.set_in(node, (node.name, [self._types["object"]]))
        else:
            # Visit all type declarations of the variable.
            typelist = list()
            for t in node.types:
                # Check whether they have been defined.
                if not t in self._types:
                    raise SemanticError(
                        "Error unknown type " + t + " used in predicate definition"
                    )
                typelist.append(self._types[t])
            # Store variable information (var_name, tuple(types)) in node.
            self.set_in(node, (node.name, tuple(typelist)))

    def visit_action_stmt(self, node):
        """Visits a HDDL action statement."""
        
        signature = list()
        # Visit all parameters and create signature.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Visit the precondition statement.
        node.precond.accept(self)
        precond = self.get_in(node.precond)

        # Visit the effect statement.
        node.effect.accept(self)
        effect = self.get_in(node.effect)

        # Create new HDDL action and store in node.
        self.set_in(node, hddl.Action(node.name, signature, precond, effect))
        

    def add_precond(self, precond, c, is_negative=False):
        from .parser import Variable
        # cases without preconditions
        if c.key == None:
            return

        predDef = self._predicates[c.key]
        signature = list()
        count = 0

        # Check for correct number of arguments.
        if len(c.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for predicate " + c.key
            )

        # Apply to all arguments.
        for v in c.children:
            if isinstance(v.key, Variable):
                signature.append((v.key.name, predDef.signature[count][1]))
            else:
                signature.append((v.key, predDef.signature[count][1]))
            count += 1

        # Add predicate to the appropriate precondition list based on positive/negative.
        if is_negative:
            precond.neglist.add(hddl.Predicate(c.key, signature))
        else:
            precond.poslist.add(hddl.Predicate(c.key, signature))

    #NOTE: still considering situations with empty predicates (predicate.key == None)
    def visit_precondition_stmt(self, node):
        # precond_formula = self._traverse_formula(node.formula)
        precond = hddl.Precondition()
        formula = node.formula
        
        # Handling 'and' operator.
        if formula.key == "and":
            for c in formula.children:
                if not isinstance(c.key, str):
                    raise SemanticError(
                        "Error predicate with non str key: "
                        + "".join([c2.key.name for c2 in formula.children])
                    )
                is_negative = False
                if c.key == "not":
                    # Handle negative preconditions.
                    is_negative = True
                    c = c.children[0]
                    #self.add_precond(precond, c.children[0], is_negative=True)
                
                if c.key !=  None and not c.key in self._predicates:
                    raise SemanticError(
                        "Error unknown predicate '{}'"
                        " used in precondition of action".format(c.key)
                    )
                self.add_precond(precond, c, is_negative)
        else:
            if formula.key == "not":
                # Handle negative preconditions.
                self.add_precond(precond, formula.children[0], is_negative=True)
            else:
                if formula.key !=  None and not formula.key in self._predicates:
                    raise SemanticError(
                        f"Error: predicate {formula.key} in precondition is not defined"
                    )
                self.add_precond(precond, formula)
                            

        self.set_in(node, precond)
        
        
    # NOTE: eventually we will need some type of evaluation using predicate formula as
        # we add new operations, in order to avoid too many edge cases as we grow the evaluation of 'visit_precondition_stmt'
    # def _traverse_formula(self, node):
    #     """
    #     Traverse and process a logical formula in an HDDL domain.

    #     :param node: The formula node to process.
    #     :return: Processed formula as a Predicate, conjunction, or disjunction.
    #     """
    #     if node.key is None:
    #         return hddl.Formula(LogicalOperator.NOOP, None)
    #     elif node.key in self._predicates:
    #         return hddl.Formula(LogicalOperator.LITERAL, self.add_predicate(node))
    #     else:
    #         operator = node.key.upper()
    #         if operator == '=':
    #             variables = [n.key.name for n in node.children]
    #             assert len(variables) == 2
    #             return hddl.Formula(LogicalOperator.EQUAL, variables)
            
    #         operands = [self._traverse_formula(child) for child in node.children]
    #         if operator == 'AND':
    #             return hddl.Formula(LogicalOperator.AND, operands)
    #         elif operator == 'OR':
    #             return hddl.Formula(LogicalOperator.OR, operands)
    #         elif operator == 'NOT':
    #             return hddl.Formula(LogicalOperator.NOT, operands)
    #         else:
    #             # Handle other operators or raise an error
    #             raise SemanticError(
    #             "Error: invalid operator " + operator
    #             )

        

    def add_predicate(self, node):
        from .parser import Variable
        # cases without preconditions
        if node.key == None:
            return

        predDef = self._predicates[node.key]
        signature = list()
        count = 0

        # Check for correct number of arguments.
        if len(node.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for predicate " + node.key
            )

        # Apply to all arguments.
        for v in node.children:
            if isinstance(v.key, Variable):
                signature.append((v.key.name, predDef.signature[count][1]))
            else:
                signature.append((v.key, predDef.signature[count][1]))
            count += 1

        # Add predicate to the appropriate precondition list based on positive/negative.
        return hddl.Predicate(node.key, signature)


    def add_effect(self, effect, c):
        """Helper function for visit_effect_stmt.

        Keyword arguments:
        effect -- instance of the effect data structure
        c -- the formula representing the effect that we want to add to the
             addlist or dellist
        """
        # Needed for instance check.
        from .parser import Variable

        nextPredicate = None
        isNegative = False
        if c.key == "not":
            # This is a negative effect, only one child allowed.
            if len(c.children) != 1:
                raise SemanticError(
                    "Error not statement with multiple " "children in effect of action"
                )
            nextPredicate = c.children[0]
            isNegative = True
        else:
            nextPredicate = c
        
        #EMPTY FORMULA
        if nextPredicate.key == None:
            return
        
        # Check whether predicate was defined previously.
        if nextPredicate == None:
            raise SemanticError("Error: NoneType predicate used in effect of " "action")
        
        if not nextPredicate.key in self._predicates:
            raise SemanticError(
                "Error: unknown predicate \'%s\' used in effect "
                "of action" % nextPredicate.key 
            )
        
        predDef = self._predicates[nextPredicate.key]
        signature = list()
        count = 0
        # Check whether predicate is used with the correct signature.
        if len(nextPredicate.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for "
                "predicate " + nextPredicate.key + " in effect of action"
            )
        # Apply to all parameters.
        for v in nextPredicate.children:
            if isinstance(v.key, Variable):
                signature.append((v.key.name, predDef.signature[count][1]))
            else:
                signature.append((v.key, predDef.signature[count][1]))
            count += 1

        # Add a new effect to the positive or negative effects respectively.
        if isNegative:
            effect.dellist.add(hddl.Predicate(nextPredicate.key, signature))
        else:
            effect.addlist.add(hddl.Predicate(nextPredicate.key, signature))

    def visit_effect_stmt(self, node):
        """Visits a HDDL effect statement."""
        formula = node.formula
        effect = hddl.Effect()
        # For now we only allow 'and' in the effect.
        if formula.key == "and":
            for c in formula.children:
                # Call helper.
                self.add_effect(effect, c)
        else:
            # Call helper.
            self.add_effect(effect, formula)
        # Store effect in node.
        self.set_in(node, effect)

    def visit_task_stmt(self, node):
        """Visits a HDDL task statement."""
        signature = list()

        # Visit all parameters and create signature.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Create new HDDL task and store in node.
        self.set_in(node, hddl.Task(node.name, signature))

    def visit_method_stmt(self, node):
        """Visits a HDDL method statement."""
        
        signature = list()
        # Visit all parameters and create signature.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Visit the precondition statement.
        precond = None
        if node.precond  != None:
            node.precond.accept(self)
            precond = self.get_in(node.precond)

        # Visit the decomposed task.
        node.decomposed_task.accept(self)
        decomposed_task = self.get_in(node.decomposed_task)

        # Visit subtasks:
        node.ordered_subtasks.accept(self)   
        ordered_subtasks = self.get_in(node.ordered_subtasks)

        # Create new HDDL action and store in node.
        self.set_in(node, hddl.Method(node.name, signature, precond, decomposed_task, ordered_subtasks))
    

    def visit_ordered_subtasks(self, node):
        """Visits the subtasks within a method in HDDL.
        NOTE: we do not considere here arbitrarly task namming in primitive tasks like (t1 (primitive)) :subbtasks(and (primitive) (abstract)...)
        """
        subtasks = list()
        formula = node.formula
               
        # For the given formula (which represents the subtasks), 
        # TODO: This is terrible, improve it later
        if formula.key == "and":
            for subtask_formula in formula.children:
                subtasks.append( self._process_subtasks(node, subtask_formula.key, subtask_formula.children) )
        else:
            subtasks.append( self._process_subtasks(node, formula.key, formula.children) )
        self.set_in(node, hddl.OrderedSubtasks(subtasks))
    
    def _process_subtasks(self, node, subtask_name, subtask_formula):
        subtask_signature = []
        
        # in cases tasks being named ( ex: (t1 (move ?x ?y)) => move ?x ?y ) * for now we ignore the task ID
        if not subtask_name in self._actions and not subtask_name in self._tasks:
            subtask_formula = subtask_formula[0] 
            subtask_name = subtask_formula.key
            subtask_variables = subtask_formula.children
        else:
            subtask_variables = subtask_formula

        if subtask_name in self._tasks:
            task_definition_signature = self._tasks[subtask_name].signature
            type_of_task = 'abstract'
        elif subtask_name in self._actions:
            task_definition_signature = self._actions[subtask_name].signature
            type_of_task = 'primitive'
        else:
            raise SemanticError(f"[SUBTASK ERROR]: subtask \'{subtask_name}\' not defined {self._actions}\n\n{self._tasks}")
                    
        if len(task_definition_signature) != len(subtask_variables):
            raise SemanticError(f"[SUBTASK ERROR] number of parameters on subtask \'{subtask_name}\' differs from its declaration")
        
        for idx in range(len(subtask_variables)):
            fact = subtask_variables[idx].key
            if fact in self._constants:
                constant = fact
                type_constant = self._constants[fact]
                subtask_signature.append((fact, type_constant))
            else:
                var = fact
                # check if variable was declared in :parameter
                if not var.name in node.helper_params:
                    raise SemanticError(f"[SUBTASK ERROR] {subtask_name}: {var.name} not defined")
                #check if types required by subtasks match to task/action declaration
                else:
                    var_instance = node.helper_params[var.name]
                    var_definition_signature = task_definition_signature[idx]
                    for i in range(len(var_definition_signature[1])):
                        #if var_definition_signature[1][i].name != var_instance.types[i]:
                        if not self._helper_check_type_signature(var_definition_signature[1][i].name, var_instance.types[i]):
                            raise SemanticError(f"[SUBTASK ERROR] \'{subtask_name}\': type \'{var_instance.types[i]}\' mismatch on variable \'{var.name}\', task \'{subtask_name}\' require type \'{var_definition_signature[1][i].name}\'")
                    subtask_signature.append((var_instance.name, var_instance.types))
        
        return (subtask_name,subtask_signature, type_of_task)

    

    def _helper_check_type_signature(self, type_definition, instance_type):
        
        curr_type = self._types[instance_type]
        while True:
        
            if curr_type.name == type_definition:
                return True
            elif curr_type == curr_type.parent:
                break 
            curr_type = curr_type.parent
            
        return False


    def visit_decomposed_task_stmt(self, node):
        """Visits a decomposed task statement in HDDL.
            NOTE: the method signature is not accessible from here because we cannot pass it by parameter and we have not instantiated it yet
            then we attach to variable their types in order to verify if signature on task's  definition match with method's decomposed task
        """
        task_name = node.name
        
        # Check if the task exists
        if not task_name in self._tasks:
            raise ValueError(f"[DECOMP TASK ERROR] undefined tasks \'{task_name}\' used in method decomposition")
        
        task_definition = self._tasks[task_name]
        

        # Validate that the variables of the decomposed task match the parameters of the task
        if len(node.variables) != len(task_definition.signature):
           raise ValueError(f"[DECOMP TASK ERROR] Number of variables in task {task_name} does not match task's definition.")
        
        decomposition_signature = list()
        # Visit all parameters and create a decomposition signature.
        for v in node.variables:
            v.accept(self)
            signatureTuple = self.get_in(v)
            decomposition_signature.append(signatureTuple)
                
        for i in range(len(decomposition_signature)):
            ds = decomposition_signature[i]     #decomposition signature
            ts = task_definition.signature[i]   #task signature
            for j in range(len(ds[1])):
                if(ds[1][j].name != ts[1][j].name): 
                    raise ValueError(f"[DECOMP TASK ERROR] task \'{task_name}\': Variable type ({ds[0]}, {ds[1][j].name}) not according task's definition ({ts[0]}, {ts[1][j].name}).")
        

        # Store the decomposed task in the node.
        self.set_in(node, hddl.DecomposedTask(task_name, decomposition_signature))


###############################( PROBLEM )############################################


class TraverseHDDLProblem(HDDLVisitor):
    """The HDDL-problem Visitor.

    Expands the functionality of the HDDLVisitor to traversal of ASTs that
    represent a HDDL-problem file. It results in the HDDL data structure
    (pddl.py) representation of the problem file.
    """

    def get_in(self, node):
        """
        Helper method to access a global hash in which information for each
        node in the AST can be stored.
        """
        return self._nodeHash[node]

    def set_in(self, node, val):
        """
        Helper method to write a global hash in which information for each node
        in the AST can be stored.
        """
        self._nodeHash[node] = val

    def get_problem(self):
        """Getter for the resulting pddl-problem data structure."""
        return self._problemDef

    def __init__(self, domain):
        """Constructor for pddl-problem visitor.

        Keyword arguments:
        domain -- the coressponding pddl-domain datastrucutre
        """
        self._domain = domain
        self._nodeHash = dict()
        self._objects = dict()
        self._problemDef = None

    def visit_problem_def(self, node):
        """Visits a HDDL-problem definition."""
        # Check whether the in the problem file referenced domain name matches
        # the supplied domain data structure.
        
        if node.domainName != self._domain.name:
            raise SemanticError(
                "Error trying to parse problem file with "
                "domain: %s together with a domain file that "
                "specifies domain: %s" % (node.domainName, self._domain.name)
            )
        # Apply to all object definitions.
        for o in node.objects:
            o.accept(self)

        # Apply to the initial state definition.
        node.init.accept(self)
        init_list = self.get_in(node.init)

        
        # Apply to the htn definition
        node.htn.accept(self)
        htn_list = self.get_in(node.htn)
        
        # Apply to the goal state definition.
        goal_list = []
        if(node.goal != None):
            node.goal.accept(self)
            goal_list = self.get_in(node.goal)

        # Create the problem data structure.
        self._problemDef = hddl.Problem(
            node.name, self._domain, self._objects, init_list, htn_list, goal_list
        )

    # TODO: maybe change here the subtasks here are already grounded so we don't have 'signature' exatcly.
    def visit_htn_stmt(self, node):
        subtasks = list()
        formula = node.ordered_subtasks.formula
               
        # For the given formula (which represents the tasks to perform in the problem instance), 
        # we only allow 'and' as the outermost connective.
        # NOTE: only abstract tasks  allowed
        if formula.key == "and":
            for subtask_formula in formula.children:
                subtask_name = subtask_formula.key
                subtask_facts = subtask_formula.children
                
                if not subtask_name in self._domain.tasks:
                    subtask_formula = subtask_formula.children[0]
                    subtask_name = subtask_formula.key
                    subtask_facts = subtask_formula.children 
                
                if subtask_name in self._domain.tasks:
                    subtask_signature = []
                    task_definition_signature = self._domain.tasks[subtask_name].signature
                    # check number of parameters compared to domain's task definition
                    if len(subtask_facts) != len(task_definition_signature):
                        raise SemanticError(f'[SUBTASK ERROR]: Task \'{subtask_name}\' requires {len(task_definition_signature)} fatcs, instead of {len(subtask_facts)}')    
                    
                    for i,f in enumerate(subtask_facts):
                        # check if task's object is declared
                        if not  f.key in self._objects:
                            raise SemanticError(f"[SUBTASK ERROR]: fact \'{f.key}\' on Task \'{subtask_name}\' no declared on objects")    
                        # check if object  type  match domain's task definition requirements
                        if not self._helper_check_type_signature(task_definition_signature[i][1][0].name, self._objects[f.key].name):
                            raise SemanticError(f"[SUBTASK ERROR]: Task \'{subtask_name}\' containing fact \'{f.key} - {self._objects[f.key]}\' requires type \'{task_definition_signature[i][1][0]}\'")    
                        
                        subtask_signature.append((f.key, task_definition_signature[i][1])) #NOTE: not sure if the problem subtask should be instantiated this way                                
                    subtasks.append( (subtask_name, subtask_signature) )
                    
                else:
                    raise SemanticError(f"[SUBTASK ERROR]: subtask \'{subtask_name}\' not defined")
        self.set_in(node, hddl.OrderedSubtasks(subtasks))

    def _helper_check_type_signature(self, type_definition, instance_type):
        #print(f'{self._domain.types}\n{instance_type}\n{type_definition}')
        curr_type = self._domain.types[instance_type]
        #print(f'{curr_type} => {curr_type.parent}\n')
        while True:
        
            if curr_type.name == type_definition:
                return True
            elif curr_type == curr_type.parent:
                break 
            curr_type = curr_type.parent
            
        return False

    def visit_object(self, node):
        """Visits a HDDL-problem object definition."""
        type_def = None
        # Check for multiple definition of objects.
        if node.name in self._objects:
            raise SemanticError(
                "Error multiple defines of object with name " + node.name
            )
        # Untyped objects get the standard type 'object'.
        if node.typeName == None:
            type_def = self._domain.types["object"]
        else:
            # Check whether used type was introduced in domain file.
            if not node.typeName in self._domain.types:
                raise SemanticError(
                    "Error: unknown type "
                    + node.typeName
                    + " used in object definition!"
                )
            type_def = self._domain.types[node.typeName]
        self._objects[node.name] = type_def

    def visit_init_stmt(self, node):
        """Visits a HDDL-problem initial state statement."""
        initList = list()
        # Apply to all predicates in the statement.
        for p in node.predicates:
            p.accept(self)
            pred = self.get_in(p)
            initList.append(pred)
        self.set_in(node, initList)

    def add_goal(self, goal, c):
        """Helper function for visit_goal_stmt.

        Keyword arguments:
        goal -- a list of goals
        c -- a formula representing a goal we want to add to the goal list
        """
        # Check whether predicate was introduced in domain file.
        if not c.key in self._domain.predicates:
            raise SemanticError(
                "Error: unknown predicate " + c.key + " in goal definition"
            )
        # Get predicate from the domain data structure.
        predDef = self._domain.predicates[c.key]
        signature = list()
        count = 0
        # Check whether the predicate uses the correct signature.
        if len(c.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for "
                "predicate " + c.key + " in goal"
            )
        for v in c.children:
            signature.append((v.key, predDef.signature[count][1]))
            count += 1
        # Add the predicate to the goal.
        goal.append(hddl.Predicate(c.key, signature))

    def visit_goal_stmt(self, node):
        """Visits a HDDL-problem goal state statement."""
        formula = node.formula
        goal = list()
        # For now we only allow 'and' in the goal.
        if formula.key == "and":
            for c in formula.children:
                if not isinstance(c.key, str):
                    raise SemanticError(
                        "Error predicate with non str key: "
                        + "".join([c2.key.name + " " for c2 in formula.children])
                    )
                # Call helper.
                self.add_goal(goal, c)
        else:
            # Only a single predicate is allowed then (s.a.)
            if not formula.key in self._domain.predicates:
                raise SemanticError(
                    "Error: predicate in goal definition is " "not in CNF"
                )
            # Call helper.
            self.add_goal(goal, formula)
        self.set_in(node, goal)

    def visit_predicate_instance(self, node):
        """Visits a HDDL-problem predicate instance."""
        signature = list()
        # Visit all parameters.
        for o in node.parameters:
            o_type = None
            # Check whether predicate was introduced in objects or domain
            # constants.
            if not (o in self._objects or o in self._domain.constants):
                raise SemanticError(
                    "Error: object " + o + " referenced in "
                    "problem definition - but not defined"
                )
            elif o in self._objects:
                o_type = self._objects[o]
            elif o in self._domain.constants:
                o_type = self._domain.constants[o]
            signature.append((o, (o_type)))
        self.set_in(node, hddl.Predicate(node.name, signature))
