#
# This file is part of pyperplan.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>
#

"""
Classes and functions that traverse the HDDL abstract syntax tree (AST)
generated by pddl_parser.py, thereby creating the HDDL data structure.
"""

from . import hddl
from ..utils import LogicalOperator

class SemanticError(Exception):
    """Exception indicating an error during traversal of AST."""

    def __init__(self, value):
        """Constructor of SemanticError.

        Keyword arguments:
        value -- the error message
        """
        self.value = value

    def __str__(self):
        return repr(self.value)


class Visitable:
    """
    The Visitable class is part of the Visitor Pattern. Every AST node created
    by the Parser derives from this class.

    The accept-method calls the appropriate method of the visitor.
    """

    def __init__(self, vname=None):
        """Constructor of the Visitable.

        Keyword arguments:
        vname -- the name of the of the callback that will be called on the
                 visitor instance
        """
        self._visitorName = vname

    def accept(self, visitor):
        if self._visitorName == None:
            raise ValueError("Error: visit method of uninitialized visitor " "called!")
        # get the appropriate method of the visitor instance
        m = getattr(visitor, self._visitorName)
        # ensure that the method is callable
        if not hasattr(m, "__call__"):
            raise ValueError(
                "Error: cannot call undefined method: %s on "
                "visitor" % self._visitorName
            )
        # and finally call the callback
        m(self)


class HDDLVisitor:
    """
    The standard tree traversal HDDL Visitor from which other Visitors derive.

    In each node, the Visitor just applies itself to all its children.
    """

    def visit_domain_def(self, node):
        node.requirements.accept(self)
        
        if node.types != None:
            for t in node.types:
                t.accept(self)
        if node.constants != None:
            for c in node.constants:
                c.accept(self)
        node.predicates.accept(self)
        if node.actions != None:
            for a in node.actions:
                a.accept(self)
        
        if node.tasks != None:  
            for t in node.tasks:
                t.accept(self)
        
        if node.methods != None:
            for m in node.methods:
                m.accept(self)

    def visit_problem_def(self, node):
        for o in node.objects:
            o.accept(self)
        node.init.accept(self)
        node.htn.accept(self)
        if node.goal != None:
            node.goal.accept(self)

    def visit_predicates_stmt(self, node):
        for p in node.predicates:
            p.accept(self)
    
    def visit_task_stmt(self, node):
        for p in node.parameters:
            p.accept(self)

    def visit_action_stmt(self, node):
        for p in node.parameters:
            p.accept(self)
        node.precond.accept(self)
        node.effect.accept(self)

    def visit_method_stmt(self, node):
        for p in node.parameters:
            p.accept(self)
        node.precond.accept(self)
        node.decomposed_task.accept(self)
        node.ordered_subtasks.accept(self)

    def visit_htn_stmt(self, node):
        node.formula.accept(self)

    def visit_ordered_subtasks(self, node):
        node.formula.accept(self)

    def visit_decomposed_task_stmt(self, node):
        return 

    def visit_formula(self, node):
        for c in node.children:
            c.accept(self)

    def visit_type(self, node):
        return  # nothing to do right now

    def visit_effect_stmt(self, node):
        node.formula.accept(self)

    def visit_precondition_stmt(self, node):
        node.formula.accept(self)

    def visit_requirements_stmt(self, node):
        for k in node.keywords:
            k.accept(self)

    def visit_predicate(self, node):
        for p in node.parameters:
            p.accept(self)

    def visit_variable(self, node):
        pass

    def visit_init_stmt(self, node):
        for p in node.predicates:
            p.accept(self)

    def visit_goal_stmt(self, node):
        node.formula.accept(self)

    def visit_predicate_instance(self, node):
        return  # nothing to do right now

    def visit_object(self, node):
        return  # nothing to do right now

    def visit_keyword(self, node):
        return  # nothing to do right now

    



class TraverseHDDLDomain(HDDLVisitor):
    """The HDDL-domain Visitor.

    Expands the functionality of the HDDLVisitor to traversal of ASTs that
    represent a HDDL-domain file. It results in the HDDL data structure
    (pddl.py) representation of the domain file.
    """
    def get_in(self, node, aux_structure=None):
        """
        Helper method to access a global hash in which information for each
        node in the AST can be stored.
        """
        return self._nodeHash[node]

    def set_in(self, node, val):
        """
        Helper method to write a global hash in which information for each node
        in the AST can be stored.
        """
        self._nodeHash[node] = val

    def __init__(self):
        self._types = dict()
        self._predicates = dict()
        self._nodeHash = dict()
        self._requirements = set()
        self._actions = dict()
        self.domain = None
        self._objectType = hddl.Type("object", None)
        self._constants = dict()

        self._tasks = dict()
        self._methods = dict()

        self._aux_structure = None #NOTE: passing parameters for methods, actions and wharever it needs, not sure how to do that using another way

    def visit_domain_def(self, node):
        """Visits a HDDL domain definition."""
        explicitObjectDef = False
        
        # Requirements statement is optional.
        if node.requirements:
            node.requirements.accept(self)

        # Visit all type definitions.
        if node.types != None:
            for t in node.types:
                if t.name == "object":
                    explicitObjectDef = True
                t.accept(self)
                type = self.get_in(t)
                self._types[type.name] = type
                
        # Add the default object type to the type definitions,
        # if it was not explicitly created.
        if not explicitObjectDef:
            self._types["object"] = self._objectType

        '''
        #NOTE: here we need to allow new type instances in case the parent wasn't declared (apparently this is allowed)
        example: 
        Barman domain
        (:types
            anything
            container dispenser level beverage hand - anything
            shot shaker - container
            ingredient cocktail - beverage
        )
        should be equivalent to 
        (:types
            container dispenser level beverage hand - anything
            shot shaker - container
            ingredient cocktail - beverage
        )
        ''' 
        # Link all types to their parent types directly.
        for t in self._types.values():
            # Object type has no parent.
            if t.name == "object":
                continue
            if not t.parent in self._types:
                #t.parent.accept(self)
                #undeclared_type = self.get_in(t.parent)
                #self._types[undeclared_type.name] = undeclared_type
                raise SemanticError(f"[TYPE DECLARATION ERROR] parent type \'{t.parent}\' used in \'{t.name}\' not explicitly declared.") 
            
            t.parent = self._types[t.parent]

        # Visit all constants.
        if node.constants != None:
            for c in node.constants:
                c.accept(self)

        if node.tasks is not None:
            for t in node.tasks:
                t.accept(self)
                task = self.get_in(t)
                if task.name in self._tasks:
                    raise SemanticError(
                        "Error: task with name "
                        + task.name
                        + " has already been defined"
                    )
                self._tasks[task.name] = task
        
        # Visit all predicates.
        node.predicates.accept(self)
        
        # Visit all actions.
        if node.actions != None:
            for a in node.actions:
                a.accept(self)
                action = self.get_in(a)
                if action.name in self._actions:
                    raise SemanticError(
                        "Error: action with name "
                        + action.name
                        + " has already been defined"
                    )
                self._actions[action.name] = action

        # Visit all methods.
        if node.methods is not None:
            for m in node.methods:
                m.accept(self)
                method = self.get_in(m)
                if method.name in self._methods:
                    raise SemanticError(
                        "Error: method with name "
                        + task.method
                        + " has already been defined"
                    )
                self._methods[method.name] = method

        # Finally generate HDDL domain data structure.
        self.domain = hddl.Domain(
            node.name, self._types, self._predicates, self._tasks, self._actions, self._methods, self._constants
        )

    def visit_object(self, node):
        """Visits a HDDL object definition."""
        type_name = node.typeName
        if type_name == None:
            type_name = "object"
        if not type_name in self._types:
            raise SemanticError(
                "Error: unknown type \'" + type_name + "\' used in object definition!"
            )
        if node.name in self._constants:
            raise SemanticError(
                "Error: multiple defines of object with " "name " + node.name
            )
        # Add constant with its corresponding type to the constants dict.
        self._constants[node.name] = self._types[type_name]

    def visit_type(self, node):
        """Visits a HDDL type definition."""
        # Store matching parent type in node
        # (if none is given, it's always object)
        if node.parent == None:
            self.set_in(node, hddl.Type(node.name, "object"))
        else:
            self.set_in(node, hddl.Type(node.name, node.parent))

    def visit_requirements_stmt(self, node):
        """Visits a HDDL requirement statement."""
        # Visit all requirement keywords...
        for k in node.keywords:
            k.accept(self)
            requirementName = self.get_in(k)
            # ... and add them to the requirement list.
            self._requirements.add(requirementName)

    def visit_keyword(self, node):
        """Visits a HDDL keyword."""
        # Nothing to do but to store its name in the node.
        self.set_in(node, node.name)

    def visit_predicates_stmt(self, node):
        """Visits a HDDL predicate statement."""
        # Visit all predicates in the predicate statement.
        for p in node.predicates:
            p.accept(self)
            predicate = self.get_in(p)
            # Check for duplicate predicate definitions.
            if predicate.name in self._predicates:
                raise SemanticError(
                    "Error predicate with name "
                    + predicate.name
                    + " has already been defined"
                )
            # Add to predicate list.
            self._predicates[predicate.name] = predicate

    def visit_predicate(self, node):
        """Visits a HDDL predicate."""
        signature = list()
        # Visit all predicate parameters.
        for v in node.parameters:
            
            v.accept(self)
            signatureTuple = self.get_in(v)
            # Append each parameter to the predicate signature.
            signature.append(signatureTuple)
        # Create new HDDL predicate and store it in node.
        self.set_in(node, hddl.Predicate(node.name, signature))

    def visit_variable(self, node):
        """Visits a HDDL variable."""
        # If there is no type given, its always of type 'object'.
        if not node.typed:
            self.set_in(node, (node.name, [self._types["object"]]))
        else:
            # Visit all type declarations of the variable.
            typelist = list()
            for t in node.types:
                # Check whether they have been defined.
                if not t in self._types:
                    raise SemanticError(
                        "Error unknown type " + t + " used in predicate definition"
                    )
                typelist.append(self._types[t])
            # Store variable information (var_name, tuple(types)) in node.
            self.set_in(node, (node.name, tuple(typelist)))

    def visit_action_stmt(self, node):
        """Visits a HDDL action statement."""
        
        signature = list()
        # Visit all parameters and create signature.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Visit the precondition statement.
        #node.precond.accept(self)
        #precond = self.get_in(node.precond)
        # Visit the precondition statement.
        precond = None
        if node.precond  != None:
            node.precond.accept(self)
            precond = self.get_in(node.precond)

        # Visit the effect statement.
        node.effect.accept(self)
        effect = self.get_in(node.effect)

        # Create new HDDL action and store in node.
        self.set_in(node, hddl.Action(node.name, signature, precond, effect))
    
    def _process_signature(self, node, predicate_definition):
        """
        Process the signature for a given node and its predicate definition.
        """
        from .parser import Variable
        signature = []
        if len(node.children) != len(predicate_definition.signature):
            raise SemanticError(f"Error: wrong number of arguments for predicate {node.key}")

        for count, child in enumerate(node.children):
            if isinstance(child.key, Variable):
                signature.append((child.key.name, predicate_definition.signature[count][1]))
            else:
                signature.append((child.key, predicate_definition.signature[count][1]))
        return signature

    def _handle_equality(self, precond, children):
        """
        Handle equality conditions.
        """
        literal_0 = children[0].key.name
        literal_1 = children[1].key.name
        precond.neqlist.add((hddl.Predicate(literal_0, []), hddl.Predicate(literal_1, [])))
        
    def _handle_predicate(self, precond, node, is_negative=False):
        """
        Handle adding a predicate to the precondition.
        """
        predicate_def = self._predicates[node.key]
        signature = self._process_signature(node, predicate_def)
        if is_negative:
            precond.neglist.add(hddl.Predicate(node.key, signature))
        else:
            precond.poslist.add(hddl.Predicate(node.key, signature))

    def _add_precond(self, precond, node, is_equality=False, is_negative=False):
        """
        Add a precondition, adjusted to support recursive processing.
        """
        if is_equality:
            self._handle_equality(precond, node)
        else:
            self._handle_predicate(precond, node, is_negative)

    def _process_node(self, precond, node, is_negative=False):
        """
        Process a node in the precondition tree recursively.
        """
        if node.key is None:
            # Skip or handle empty nodes
            return
    
        if node.key == "and":
            # Handle conjunctions by iterating over all children
            for child in node.children:
                self._process_node(precond, child, is_negative)
        elif node.key == "not":
            # Negation flips the is_negative flag for its child node
            self._process_node(precond, node.children[0], not is_negative)
        elif node.key == "=":
            # Handle equality differently, assuming two children to compare
            self._add_precond(precond, node.children, is_equality=True, is_negative=is_negative)
        else:
            # Handle base case (predicate)
            self._add_precond(precond, node, is_negative=is_negative)

    def visit_precondition_stmt(self, node):
        """
        Visit and process a precondition statement, now using recursive processing.
        """
        precond = hddl.Precondition()
        self._process_node(precond, node.formula)
        self.set_in(node, precond)

    def add_predicate(self, node):
        from .parser import Variable
        # cases without preconditions
        if node.key == None:
            return

        predDef = self._predicates[node.key]
        signature = list()
        count = 0

        # Check for correct number of arguments.
        if len(node.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for predicate " + node.key
            )

        # Apply to all arguments.
        for v in node.children:
            if isinstance(v.key, Variable):
                signature.append((v.key.name, predDef.signature[count][1]))
            else:
                signature.append((v.key, predDef.signature[count][1]))
            count += 1

        # Add predicate to the appropriate precondition list based on positive/negative.
        return hddl.Predicate(node.key, signature)


    def add_effect(self, effect, c):
        """Helper function for visit_effect_stmt.

        Keyword arguments:
        effect -- instance of the effect data structure
        c -- the formula representing the effect that we want to add to the
             addlist or dellist
        """
        # Needed for instance check.
        from .parser import Variable

        nextPredicate = None
        isNegative = False
        if c.key == "not":
            # This is a negative effect, only one child allowed.
            if len(c.children) != 1:
                raise SemanticError(
                    "Error not statement with multiple " "children in effect of action"
                )
            nextPredicate = c.children[0]
            isNegative = True
        else:
            nextPredicate = c
        
        #EMPTY FORMULA
        if nextPredicate.key == None:
            return
        
        # Check whether predicate was defined previously.
        if nextPredicate == None:
            raise SemanticError("Error: NoneType predicate used in effect of " "action")
        
        if not nextPredicate.key in self._predicates:
            raise SemanticError(
                "Error: unknown predicate \'%s\' used in effect "
                "of action" % nextPredicate.key 
            )
        
        predDef = self._predicates[nextPredicate.key]
        signature = list()
        count = 0
        # Check whether predicate is used with the correct signature.
        if len(nextPredicate.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for "
                "predicate " + nextPredicate.key + " in effect of action"
            )
        # Apply to all parameters.
        for v in nextPredicate.children:
            if isinstance(v.key, Variable):
                signature.append((v.key.name, predDef.signature[count][1]))
            else:
                signature.append((v.key, predDef.signature[count][1]))
            count += 1

        # Add a new effect to the positive or negative effects respectively.
        if isNegative:
            effect.dellist.add(hddl.Predicate(nextPredicate.key, signature))
        else:
            effect.addlist.add(hddl.Predicate(nextPredicate.key, signature))

    def visit_effect_stmt(self, node):
        """Visits a HDDL effect statement."""
        formula = node.formula
        effect = hddl.Effect()
        # For now we only allow 'and' in the effect.
        if formula.key == "and":
            for c in formula.children:
                # Call helper.
                self.add_effect(effect, c)
        else:
            # Call helper.
            self.add_effect(effect, formula)
        # Store effect in node.
        self.set_in(node, effect)

    def visit_task_stmt(self, node):
        """Visits a HDDL task statement."""
        signature = list()

        # Visit all parameters and create signature.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Create new HDDL task and store in node.
        self.set_in(node, hddl.Task(node.name, signature))

    def visit_method_stmt(self, node):
        """
        Processes a method statement within an HDDL domain, gathering all necessary components
        such as parameters, preconditions, decomposed task, and ordered subtasks, then creating
        a method object to represent this structure.

        Args:
            node: The current method statement node being visited.
        """
        signature = list()
        # Extract method signature from parameters.
        for v in node.parameters:
            v.accept(self)
            signatureTuple = self.get_in(v)
            signature.append(signatureTuple)

        # Process precondition, if present.
        precond = None
        if node.precond  != None:
            node.precond.accept(self)
            precond = self.get_in(node.precond)

        # Process the composed task.
        node.decomposed_task.accept(self)
        composed_task = self.get_in(node.decomposed_task)

        # Process ordered subtasks.
        node.ordered_subtasks.accept(self)   
        ordered_subtasks = self.get_in(node.ordered_subtasks)
        # Create new HDDL action and store in node.
        self.set_in(node, hddl.Method(node.name, signature, precond, composed_task, ordered_subtasks))
    
    def visit_decomposed_task_stmt(self, node):
        """
        Processes a decomposed task statement within an HDDL method, ensuring the specified task
        matches with its definition in terms of variable types and counts.

        Args: node: The AST node representing the decomposed task statement.

        Raises: ValueError: If the task is undefined or if there's a mismatch in variable types or counts.
        """
        task_name = node.name
        if task_name not in self._tasks:
            raise ValueError(f"Undefined task '{task_name}' used in method decomposition.")

        # Retrieve task definition from domain specifications.
        task_definition = self._tasks[task_name]

        # Construct and validate the decomposition signature based on the task definition.
        decomposition_signature = self._construct_decomposition_signature(node, task_definition)

        # After validation, store the structured decomposed task in the node.
        self.set_in(node, hddl.Task(task_name, decomposition_signature))

    def visit_ordered_subtasks(self, node):
        """
        Visits the subtasks within a method in HDDL.
        
        Each subtasks is processed getting its parameters signature
        """
        subtasks = list()
        formula = node.formula
               
        # For the given formula (which represents the subtasks), 
        # TODO: This is terrible, improve it later
        if formula.key == "and":
            for subtask_formula in formula.children:
                subtasks.append( self._process_subtasks(node, subtask_formula.key, subtask_formula.children) )
        else:
            subtasks.append( self._process_subtasks(node, formula.key, formula.children) )
        self.set_in(node, subtasks)
    
    def _process_subtasks(self, node, subtask_name, subtask_formula):
        subtask_signature = []
        if subtask_name is None:
            # NOTE: important to use 'none' here
            return hddl.Task(subtask_name, subtask_signature, 'none')
        
        # Extract subtask name and variables, handling named tasks.    
        subtask_name, subtask_variables = self._extract_subtask_name_and_variables(subtask_name, subtask_formula)
    
        # Determine the type of task and its definition signature.
        try:
            type_of_task, task_definition_signature = self._get_task_type_and_signature(subtask_name)
        except SemanticError as e:
            error_msg = f"{e} (occurred in subtask '{subtask_name}')"
            raise SemanticError(error_msg) from None
        
        # Validate the number of variables against the task's definition.
        if len(task_definition_signature) != len(subtask_variables):
            raise SemanticError(f"number of parameters on subtask \'{subtask_name}\' differs from its declaration")
        
        # Create subtasks signature, each variable should match parameter requirements
        for idx, variable in enumerate(subtask_variables):
            variable = variable.key
            lifted_parameter = node.helper_params.get(variable.name)
            parameter_signature = task_definition_signature[idx]
            
            try:
                var_signature = self._variable_signature(variable, lifted_parameter, parameter_signature)
            except SemanticError as e:
                error_msg = f"{e} (cccurred in subtask '{subtask_name}')"
                raise SemanticError(error_msg) from None
            
            subtask_signature.append(var_signature)

        return hddl.Task(subtask_name, subtask_signature, type_of_task)

    def _get_task_type_and_signature(self, subtask_name):
        """
        Determines the type of task (abstract or primitive) and fetches its definition signature.
        Args: subtask_name: Name of the subtask.
        Returns: Tuple containing the type of task and its definition signature.
        Raises: SemanticError: If the subtask is not defined.
        """
        if subtask_name in self._tasks:
            return 'abstract', self._tasks[subtask_name].signature
        elif subtask_name in self._actions:
            return 'primitive', self._actions[subtask_name].signature
        else:
            raise SemanticError(f"Subtask '{subtask_name}' is not defined.")


    def _extract_subtask_name_and_variables(self, subtask_name, subtask_formula):
        """
        Extracts the subtask name and variables, especially handling tasks with IDs.

        Args:
            subtask_name: Initial subtask name that might include an ID.
            subtask_formula: Formula from which to extract subtask details.

        Returns:
            Tuple of the actual subtask name and its variables.
        """
        if not subtask_name in self._actions and not subtask_name in self._tasks:
            # Task ID is ignored, and actual task details are extracted.
            actual_subtask_name = subtask_formula[0].key
            subtask_variables = subtask_formula[0].children
        else:
            actual_subtask_name = subtask_name
            subtask_variables = subtask_formula

        return actual_subtask_name, subtask_variables

    def _variable_signature(self, variable, lifted_parameter, parameter_signature):
        if variable in self._constants:
            type_constant = self._constants[variable]
            return (variable, type_constant)
        else:
            if lifted_parameter is None:
                raise SemanticError(f"variable {variable.name} not defined")
            for i in range(len(parameter_signature[1])):
                if not self._helper_check_type_signature(parameter_signature[1][i].name, lifted_parameter.types[i]):
                    raise SemanticError(f"type \'{lifted_parameter.types[i]}\' mismatch on variable \'{variable.name}\', require type \'{parameter_signature[1][i].name}\'")
            return (lifted_parameter.name, lifted_parameter.types)

    def _helper_check_type_signature(self, type_definition, instance_type):
        curr_type = self._types[instance_type]
        while True:
            if curr_type.name == type_definition:
                return True
            elif curr_type == curr_type.parent:
                break 
            curr_type = curr_type.parent
        return False

    def _construct_decomposition_signature(self, node, task_definition):
        """
        Constructs and validates the decomposition signature for a given task based on its definition.

        Args:
            node: The AST node representing the decomposed task.
            task_definition: The task definition object from the domain.
        Returns: List of tuples representing the validated decomposition signature.
        Raises: ValueError: If there's a mismatch in the number of variables or variable types.
        """
        if len(node.variables) != len(task_definition.signature):
            raise ValueError(f"Mismatch in number of variables for task '{task_definition.name}'.")

        decomposition_signature = []
        for var_node, expected_type in zip(node.variables, task_definition.signature):
            var_node.accept(self)
            variable_info = self.get_in(var_node)
            actual_type = variable_info[1]

            if actual_type != expected_type[1]:
                raise ValueError(f"Type mismatch for variable '{variable_info[0]}' in task '{task_definition.name}', expected '{expected_type[1].name}'.")

            decomposition_signature.append(variable_info)

        return decomposition_signature



###############################( PROBLEM )############################################


class TraverseHDDLProblem(HDDLVisitor):
    """The HDDL-problem Visitor.

    Expands the functionality of the HDDLVisitor to traversal of ASTs that
    represent a HDDL-problem file. It results in the HDDL data structure
    (hddl.py) representation of the problem file.
    """

    def get_in(self, node):
        """
        Helper method to access a global hash in which information for each
        node in the AST can be stored.
        """
        return self._nodeHash[node]

    def set_in(self, node, val):
        """
        Helper method to write a global hash in which information for each node
        in the AST can be stored.
        """
        self._nodeHash[node] = val

    def get_problem(self):
        """Getter for the resulting pddl-problem data structure."""
        return self._problemDef

    def __init__(self, domain):
        """Constructor for pddl-problem visitor.

        Keyword arguments:
        domain -- the coressponding pddl-domain datastrucutre
        """
        self._domain = domain
        self._nodeHash = dict()
        self._objects = dict()
        self._problemDef = None

    def visit_problem_def(self, node):
        """Visits a HDDL-problem definition."""
        # Check whether the in the problem file referenced domain name matches
        # the supplied domain data structure.
        
        if node.domainName != self._domain.name:
            raise SemanticError(
                "Error trying to parse problem file with "
                "domain: %s together with a domain file that "
                "specifies domain: %s" % (node.domainName, self._domain.name)
            )
        # Apply to all object definitions.
        for o in node.objects:
            o.accept(self)

        # Apply to the initial state definition.
        node.init.accept(self)
        init_list = self.get_in(node.init)

        
        # Apply to the htn definition
        node.htn.accept(self)
        htn_list = self.get_in(node.htn)
        
        # Apply to the goal state definition.
        goal_list = []
        if(node.goal != None):
            node.goal.accept(self)
            goal_list = self.get_in(node.goal)

        # Create the problem data structure.
        self._problemDef = hddl.Problem(
            node.name, self._domain, self._objects, init_list, htn_list, goal_list
        )

    # TODO: maybe change here the subtasks here are already grounded so we don't have 'signature' exatcly.
    def visit_htn_stmt(self, node):
        '''
        Process an HTN statement node within the HDDL problem.

        This method handles the 'and' connective in HTN tasks, validating and 
        extracting subtask information in accordance with the domain definition.
        '''
        
        formula = node.ordered_subtasks.formula
               
        # For the given formula (which represents the tasks to perform in the problem instance), 
        # only 'and' operations for now.
        if formula.key != "and":
            raise SemanticError(f"[SUBTASK ERROR]: invalid operator \'{formula.key}\'")
        
        subtasks = list()
        for subtask_formula in formula.children:
            subtask_name = subtask_formula.key
            subtask_facts = subtask_formula.children
            
            #NOTE: in case we have pseudonames for subtasks, discard it, ex: :ordered-subtasks(and (t1 (do a b) (t2 (do b c)))) => :ordered-subtasks(and (do a b) (do b c)))
            #TODO: later these name will be used for partial-order problems
            if not subtask_name in self._domain.tasks:
                subtask_formula = subtask_formula.children[0]
                subtask_name = subtask_formula.key
                subtask_facts = subtask_formula.children 
            
            subtasks = self._helper_validate_and_append_subtask(subtasks, subtask_name, subtask_facts)
            
        self.set_in(node, subtasks)

    def visit_object(self, node):
        """Visits a HDDL-problem object definition."""
        type_def = None
        # Check for multiple definition of objects.
        if node.name in self._objects:
            raise SemanticError(
                "Error multiple defines of object with name " + node.name
            )
        # Untyped objects get the standard type 'object'.
        if node.typeName == None:
            type_def = self._domain.types["object"]
        else:
            # Check whether used type was introduced in domain file.
            if not node.typeName in self._domain.types:
                raise SemanticError(
                    "Error: unknown type "
                    + node.typeName
                    + " used in object definition!"
                )
            type_def = self._domain.types[node.typeName]
        self._objects[node.name] = type_def

    def visit_init_stmt(self, node):
        """Visits a HDDL-problem initial state statement."""
        initList = list()
        # Apply to all predicates in the statement.
        for p in node.predicates:
            p.accept(self)
            pred = self.get_in(p)
            initList.append(pred)
        self.set_in(node, initList)

    def visit_goal_stmt(self, node):
        """Visits a HDDL-problem goal state statement."""
        formula = node.formula
        goal = list()
        # For now we only allow 'and' in the goal.
        if formula.key == "and":
            for c in formula.children:
                if not isinstance(c.key, str):
                    raise SemanticError(
                        "Error predicate with non str key: "
                        + "".join([c2.key.name + " " for c2 in formula.children])
                    )
                self._helper_add_goal(goal, c)
        else:
            # Only a single predicate is allowed then (s.a.)
            if not formula.key in self._domain.predicates:
                raise SemanticError(
                    "Error: predicate in goal definition is " "not in CNF"
                )
            self._helper_add_goal(goal, formula)
        self.set_in(node, goal)

    def visit_predicate_instance(self, node):
        """Visits a HDDL-problem predicate instance."""
        signature = list()
        # Visit all parameters.
        for o in node.parameters:
            o_type = None
            # Check whether predicate was introduced in objects or domain
            # constants.
            if not (o in self._objects or o in self._domain.constants):
                raise SemanticError(
                    "Error: object " + o + " referenced in "
                    "problem definition - but not defined"
                )
            elif o in self._objects:
                o_type = self._objects[o]
            elif o in self._domain.constants:
                o_type = self._domain.constants[o]
            signature.append((o, (o_type)))
        self.set_in(node, hddl.Predicate(node.name, signature))
    
    def _helper_validate_and_append_subtask(self, subtasks, subtask_name, subtask_facts):
        '''
         Validates a subtask and appends it to the subtasks list if valid.

        Args:
            subtasks: The list of subtasks to append to.
            subtask_name: The name of the subtask.
            subtask_facts: The facts associated with the subtask.
        '''
        
        if not subtask_name in self._domain.tasks:
            raise SemanticError(f"[SUBTASK ERROR]: subtask \'{subtask_name}\' not defined")
        
        subtask_signature = []
        task_definition_signature = self._domain.tasks[subtask_name].signature
        # check number of parameters compared to domain's task definition
        if len(subtask_facts) != len(task_definition_signature):
            raise SemanticError(f'[SUBTASK ERROR]: Task \'{subtask_name}\' requires {len(task_definition_signature)} fatcs, instead of {len(subtask_facts)}')    
        
        for i,f in enumerate(subtask_facts):
            # check if task's object is declared
            if not  f.key in self._objects:
                raise SemanticError(f"[SUBTASK ERROR]: fact \'{f.key}\' on Task \'{subtask_name}\' no declared on objects")    
            # check if object  type  match domain's task definition requirements
            if not self._helper_check_type_signature(task_definition_signature[i][1][0].name, self._objects[f.key].name):
                raise SemanticError(f"[SUBTASK ERROR]: Task \'{subtask_name}\' containing fact \'{f.key} - {self._objects[f.key]}\' requires type \'{task_definition_signature[i][1][0]}\'")    
            
            subtask_signature.append((f.key, task_definition_signature[i][1])) #NOTE: not sure if the problem subtask should be instantiated this way                                
        
        subtasks.append( hddl.Task(subtask_name, subtask_signature) )
        return subtasks
    
    def _helper_check_type_signature(self, type_definition, instance_type):
        """Helper function for checking parameter type considering type hierarchy.

        arguments:
            type definition -- type needed from the atom on the lifted description (action or method)
            instace type -- atom type to be grounded into the action or method
        """
        curr_type = self._domain.types[instance_type]
        while True:
            if curr_type.name == type_definition:
                return True
            elif curr_type == curr_type.parent:
                break 
            curr_type = curr_type.parent
            
        return False
    
    def _helper_add_goal(self, goal, c):
        """Helper function for visit_goal_stmt.

        Keyword arguments:
        goal -- a list of goals
        c -- a formula representing a goal we want to add to the goal list
        """
        # Check whether predicate was introduced in domain file.
        if not c.key in self._domain.predicates:
            raise SemanticError(
                "Error: unknown predicate " + c.key + " in goal definition"
            )
        # Get predicate from the domain data structure.
        predDef = self._domain.predicates[c.key]
        signature = list()
        count = 0
        # Check whether the predicate uses the correct signature.
        if len(c.children) != len(predDef.signature):
            raise SemanticError(
                "Error: wrong number of arguments for "
                "predicate " + c.key + " in goal"
            )
        for v in c.children:
            signature.append((v.key, predDef.signature[count][1]))
            count += 1
        # Add the predicate to the goal.
        goal.append(hddl.Predicate(c.key, signature))
